---
title: React Performance Optimization Techniques
description: Discover advanced techniques for optimizing React applications including memoization code splitting and virtual scrolling
date: 2024-03-05
tags:
  - React
  - Performance
  - JavaScript
  - Optimization
---

# React Performance Optimization Techniques

Performance is crucial for delivering excellent user experiences. In this guide, we'll explore advanced techniques for optimizing React applications.

## Understanding React Rendering

React re-renders components when:
1. State changes
2. Props change
3. Parent component re-renders
4. Context value changes

## Memoization with useMemo and useCallback

### useMemo for expensive calculations

```typescript
import { useMemo } from 'react';

function DataGrid({ data, filter }) {
  const filteredData = useMemo(() => {
    return data.filter(item => item.category === filter);
  }, [data, filter]);

  return (
    <div>
      {filteredData.map(item => (
        <DataRow key={item.id} data={item} />
      ))}
    </div>
  );
}
```

### useCallback for function props

```typescript
import { useCallback } from 'react';

function ParentComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return <ChildComponent onClick={handleClick} />;
}

const ChildComponent = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click me</button>;
});
```

## React.memo for Component Memoization

Prevent unnecessary re-renders:

```typescript
const ExpensiveComponent = React.memo(
  ({ data, onUpdate }) => {
    console.log('Rendering ExpensiveComponent');
    
    return (
      <div>
        {data.map(item => (
          <div key={item.id}>{item.name}</div>
        ))}
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Custom comparison function
    return prevProps.data === nextProps.data;
  }
);
```

## Code Splitting with React.lazy

Load components on demand:

```typescript
import { lazy, Suspense } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

## Virtual Scrolling

For long lists, use virtual scrolling with react-window:

```typescript
import { FixedSizeList } from 'react-window';

function VirtualList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

## Debouncing and Throttling

Control expensive operations:

```typescript
import { useState, useCallback } from 'react';
import { debounce } from 'lodash';

function SearchComponent() {
  const [results, setResults] = useState([]);

  const debouncedSearch = useCallback(
    debounce(async (query) => {
      const data = await fetchSearchResults(query);
      setResults(data);
    }, 300),
    []
  );

  const handleChange = (e) => {
    debouncedSearch(e.target.value);
  };

  return <input onChange={handleChange} />;
}
```

## Profiling with React DevTools

Use React DevTools Profiler to identify performance bottlenecks:

1. Open React DevTools
2. Go to Profiler tab
3. Click Record
4. Perform actions in your app
5. Stop recording
6. Analyze the flame graph

## Web Vitals

Monitor Core Web Vitals:

```typescript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  console.log(metric);
  // Send to your analytics service
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

## Bundle Size Optimization

Analyze and reduce bundle size:

```bash
# Analyze bundle
npm run build -- --stats
npx webpack-bundle-analyzer build/bundle-stats.json

# Use dynamic imports
const module = await import('./heavy-module');

# Tree shaking - import only what you need
import { specific } from 'lodash-es';
```

## Conclusion

Optimizing React performance requires a combination of techniques:
- Memoization to prevent unnecessary calculations
- Code splitting to reduce initial load time
- Virtual scrolling for long lists
- Profiling to identify bottlenecks

Implement these techniques strategically based on your app's specific needs and always measure the impact!
