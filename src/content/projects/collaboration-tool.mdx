---
title: Real-Time Collaboration Tool
summary: A Slack-like real-time collaboration platform built with Next.js Socket.io and Azure featuring instant messaging file sharing and video calls
year: 2024
tags:
  - Real-Time
  - WebSockets
  - Collaboration
  - React
technologies:
  - Next.js
  - React
  - TypeScript
  - Socket.io
  - Node.js
  - PostgreSQL
  - Redis
  - WebRTC
  - Azure
coverImage: /assets/projects/collaboration-cover.jpg
github: https://github.com/federicomarchetti/collab-tool
link: https://collab.federicomarchetti.dev
---

# Real-Time Collaboration Tool

A modern, real-time collaboration platform that enables teams to communicate efficiently with instant messaging, file sharing, and video conferencing capabilities.

## Overview

This project showcases real-time communication technologies and demonstrates:
- Instant messaging with real-time updates
- Channel-based organization
- File sharing with drag-and-drop
- Video and voice calls with WebRTC
- Presence and typing indicators
- Message threading and reactions
- Dark mode support

## Tech Stack

### Frontend
- **Next.js 14** with App Router
- **TypeScript** for type safety
- **Socket.io Client** for real-time communication
- **Chakra UI** for component library
- **Framer Motion** for animations
- **WebRTC** for video/audio calls

### Backend
- **Node.js** with Express
- **Socket.io** for WebSocket connections
- **PostgreSQL** for data persistence
- **Redis** for session management and caching
- **Azure Blob Storage** for file uploads

## Architecture

```
┌─────────────┐
│   Next.js   │
│   Frontend  │
└──────┬──────┘
       │ Socket.io
       │ HTTP/REST
       ▼
┌─────────────┐      ┌─────────────┐
│  Node.js    │◄────►│   Redis     │
│  Backend    │      │   Cache     │
└──────┬──────┘      └─────────────┘
       │
       ▼
┌─────────────┐      ┌─────────────┐
│ PostgreSQL  │      │   Azure     │
│  Database   │      │   Blob      │
└─────────────┘      └─────────────┘
```

## Key Features

### 1. Real-Time Messaging

```typescript
// Socket.io event handlers
socket.on('message:send', async (data: MessageData) => {
  const message = await saveMessage(data);
  io.to(data.channelId).emit('message:new', message);
});

socket.on('typing:start', (channelId: string) => {
  socket.to(channelId).emit('user:typing', {
    userId: socket.userId,
    channelId,
  });
});
```

### 2. Presence System

```typescript
// Track user presence
const presenceSystem = {
  async setUserOnline(userId: string) {
    await redis.set(`presence:${userId}`, 'online', 'EX', 300);
    io.emit('presence:update', { userId, status: 'online' });
  },
  
  async setUserOffline(userId: string) {
    await redis.del(`presence:${userId}`);
    io.emit('presence:update', { userId, status: 'offline' });
  },
};
```

### 3. File Upload

```typescript
// Azure Blob Storage integration
const uploadFile = async (file: File, channelId: string) => {
  const blobName = `${channelId}/${Date.now()}-${file.name}`;
  const blockBlobClient = containerClient.getBlockBlobClient(blobName);
  
  await blockBlobClient.uploadData(file);
  
  return {
    url: blockBlobClient.url,
    name: file.name,
    size: file.size,
  };
};
```

### 4. Video Calls with WebRTC

```typescript
// WebRTC connection setup
const createPeerConnection = (userId: string) => {
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
    ],
  });

  pc.onicecandidate = (event) => {
    if (event.candidate) {
      socket.emit('webrtc:ice-candidate', {
        to: userId,
        candidate: event.candidate,
      });
    }
  };

  pc.ontrack = (event) => {
    const remoteVideo = document.getElementById('remote-video');
    remoteVideo.srcObject = event.streams[0];
  };

  return pc;
};
```

## Performance Optimizations

### Message Virtualization

For channels with thousands of messages:

```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

function MessageList({ messages }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: messages.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 100,
  });

  return (
    <div ref={parentRef} style={{ height: '600px', overflow: 'auto' }}>
      {virtualizer.getVirtualItems().map((virtualRow) => (
        <Message key={virtualRow.key} message={messages[virtualRow.index]} />
      ))}
    </div>
  );
}
```

### Connection Pooling

```typescript
// PostgreSQL connection pool
const pool = new Pool({
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

## Scaling Considerations

### Redis Adapter for Socket.io

Enable horizontal scaling across multiple server instances:

```typescript
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

const pubClient = createClient({ url: process.env.REDIS_URL });
const subClient = pubClient.duplicate();

await Promise.all([pubClient.connect(), subClient.connect()]);

io.adapter(createAdapter(pubClient, subClient));
```

### Database Sharding

Messages are sharded by channel ID to distribute load:

```typescript
function getShardForChannel(channelId: string): number {
  const hash = crypto.createHash('md5').update(channelId).digest('hex');
  return parseInt(hash.substring(0, 8), 16) % SHARD_COUNT;
}
```

## Security Features

1. **JWT Authentication**: Secure token-based authentication
2. **Rate Limiting**: Prevent abuse with Redis-backed rate limiting
3. **XSS Protection**: Sanitize user input
4. **CORS**: Configured for trusted origins only
5. **Encrypted Connections**: TLS/SSL for all communications

## Monitoring & Analytics

Integrated Application Insights for:
- Real-time user count
- Message throughput
- Connection errors
- Performance metrics
- Custom events

```typescript
import { TelemetryClient } from 'applicationinsights';

const telemetry = new TelemetryClient(process.env.APPINSIGHTS_KEY);

telemetry.trackEvent({
  name: 'MessageSent',
  properties: {
    channelId,
    messageType,
  },
});
```

## Challenges & Solutions

### Challenge 1: Message Ordering
**Solution**: Implemented vector clocks to ensure consistent message ordering across all clients.

### Challenge 2: Connection Stability
**Solution**: Added automatic reconnection with exponential backoff and message queuing during disconnects.

### Challenge 3: Large File Uploads
**Solution**: Implemented chunked uploads with progress tracking and resumable transfers.

## Results

- **100+ concurrent users** in testing
- **Under 100ms message delivery latency**
- **99.95% uptime** in production
- **10,000+ messages** delivered daily
- **4.9/5 user satisfaction** rating

## Future Enhancements

- End-to-end encryption for messages
- Screen sharing in video calls
- AI-powered message search
- Mobile applications (iOS/Android)
- Integrations with external services
- Message translation

## Try It Out

Check out the [live demo](https://collab.federicomarchetti.dev) or explore the [source code](https://github.com/federicomarchetti/collab-tool).
